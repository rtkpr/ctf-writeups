# size-limit CTF Writeup

## 結論

本問は、RSA において **平文のサイズが modulus N を超えている** という設計ミスを突く問題である。

復号によって得られる値は平文そのものではなく `mod N` された結果に過ぎないが、

    m = m0 + k·N

という形で元の平文を表せるため、`k` を総当たりすることでフラグを復元できる。

---

## 問題設定

与えられる RSA 実装は以下の条件を持つ。

- p, q : 各 512 bit の素数
- N = p·q : 約 1024 bit
- e = 65537
- d : 秘密鍵（今回はそのまま与えられている）
- flag : 131 bytes（= 1048 bit）

暗号化処理は以下の通り。

    c = pow(flag, e, N)

ここで重要なのは、**flag のビット長が N を超えている** 点である。

---

## 脆弱性の本質

RSA では本来、平文 m は次の範囲に収まっている必要がある。

    0 ≤ m < N

しかし今回の条件では、

- N    : 約 1024 bit
- flag : 約 1048 bit

となっており、この前提が破られている。

その結果、暗号化時には内部的に

    c = flag^e mod N

が計算され、平文は N で剰余を取られた値としてしか保持されない。

---

## 復号の考え方

秘密鍵 d が与えられているため、通常の復号は可能である。

    m0 = c^d mod N

ただし、これは元の flag ではなく、次の形を満たす値の一つに過ぎない。

    m = m0 + k·N

ここで k は非負整数である。

---

## k の探索範囲

flag は 131 bytes であるため、

    0 ≤ m < 2^(8·131) = 2^1048

一方、N はおよそ 2^1024 である。

したがって、

    k < 2^(1048 − 1024) = 2^24

となり、**最大でも約 1600 万通り**の探索で済む。  
CTF の想定としては十分に現実的な範囲である。

---

## 攻撃方針

以下の手順でフラグを探索する。

1. m0 = c^d mod N を計算
2. k を 0 から 2^24 − 1 まで増加させる
3. m = m0 + k·N を計算
4. m を 131 bytes に変換
5. 次の条件で候補を絞り込む

   - ASCII printable のみ
   - `}` で終わる
   - `{` がちょうど 1 つ含まれる

---

## 攻撃コード

    #!/usr/bin/env python3

    N = 65667982563395257456152578363358687414628050739860770903063206052667362178166666380390723634587933595241827767873104710537142458025201334420236653463444534018710274020834864080096247524541536313609304410859158429347482458882414275205742819080566766561312731091051276328620677195262137013588957713118640118673
    e = 65537
    c = 58443816925218320329602359198394095572237417576497896076618137604965419783093911328796166409276903249508047338019341719597113848471431947372873538253571717690982768328452282012361099369599755904288363602972252305949989677897650696581947849811037791349546750246816657184156675665729104603485387966759433211643
    d = 14647215605104168233120807948419630020096019740227424951721591560155202409637919482865428659999792686501442518131270040719470657054982576354654918600616933355973824403026082055356501271036719280033851192012142309772828216012662939598631302504166489383155079998940570839539052860822636744356963005556392864865

    FLAG_LEN = 131
    MAX_K = 1 << 24

    def is_printable_ascii(bs):
        return all(32 <= b <= 126 for b in bs)

    def main():
        m0 = pow(c, d, N)

        for k in range(MAX_K):
            m = m0 + k * N
            b = m.to_bytes(FLAG_LEN, "big")

            if not b.endswith(b"}"):
                continue
            if b.count(b"{") != 1:
                continue
            if not is_printable_ascii(b):
                continue

            print(b.decode("ascii"))
            return

        print("flag not found")

    if __name__ == "__main__":
        main()

---

## フラグ

    TSGLIVE{Tttthhhhhiiiiiiisssss iiiiiiiiiisssss aaaaaaaaaaaaaa tooooooooooooooooooooo looooooooooooooooong fllllaaaaaaaaaaaaaaaaaag!}

---

## 学び

- RSA では **平文サイズが N 未満であることを必ず保証する必要がある**
- 生の RSA（パディングなし）は設計ミスに極めて弱い
- 実運用では OAEP などの安全なパディング方式を使用すべきである

CTF では定番だが、RSA の設計原則を再確認できる良い問題だった。
